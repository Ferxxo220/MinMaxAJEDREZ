import pygame
import sys
import copy
import random
import time



class Ajedrez:
    def __init__(self):
        self.tablero = [
            ["ğŸ¤", "ğŸ´", "ğŸ©", "ğŸ‘©", "ğŸ‘‘", "ğŸ©", "ğŸ´", "ğŸ¤"],
            ["âš«", "âš«", "âš«", "âš«", "âš«", "âš«", "âš«", "âš«"],
            ["â¬œ", "â¬›", "â¬œ", "â¬›", "â¬œ", "â¬›", "â¬œ", "â¬›"],
            ["â¬›", "â¬œ", "â¬›", "â¬œ", "â¬›", "â¬œ", "â¬›", "â¬œ"],
            ["â¬œ", "â¬›", "â¬œ", "â¬›", "â¬œ", "â¬›", "â¬œ", "â¬›"],
            ["â¬›", "â¬œ", "â¬›", "â¬œ", "â¬›", "â¬œ", "â¬›", "â¬œ"],
            ["âšª", "âšª", "âšª", "âšª", "âšª", "âšª", "âšª", "âšª"],
            ["ğŸ°", "ğŸ ", "â›ª", "ğŸ‘¸", "ğŸ¤´", "â›ª", "ğŸ ", "ğŸ°"]
        ]
        self.blancas = ["ğŸ°", "ğŸ ", "â›ª", "ğŸ‘¸", "ğŸ¤´", "âšª"]
        self.negras = ["ğŸ¤", "ğŸ´", "ğŸ©", "ğŸ‘©", "ğŸ‘‘", "âš«"]
        self.columnas = ["a", "b", "c", "d", "e", "f", "g", "h"]
        self.turno_negras = False  
        self.game = True



    def ajedrez_a_matriz(self, pos):
        if len(pos) < 2:
            raise ValueError("Coordenada incompleta")
        columna = pos[0].lower()
        try:
            fila = int(pos[1])
        except ValueError:
            raise ValueError("La fila debe ser un nÃºmero")
        if columna < 'a' or columna > 'h' or fila < 1 or fila > 8:
            raise ValueError("Coordenada fuera del rango del tablero")
        fila_matriz = 8 - fila
        columna_matriz = ord(columna) - ord('a')
        return fila_matriz, columna_matriz

    def sinPiezas(self, x1, y1, x2, y2, tablero=None):
        if tablero is None:
            tablero = self.tablero
        dx = (x2 - x1) // max(1, abs(x2 - x1)) if x2 != x1 else 0
        dy = (y2 - y1) // max(1, abs(y2 - y1)) if y2 != y1 else 0
        x, y = x1 + dx, y1 + dy
        while (x, y) != (x2, y2):
            if tablero[x][y] not in ["â¬œ", "â¬›"]:
                return False
            x += dx
            y += dy
        return True

    def es_movimiento_valido(self, pieza, x1, y1, x2, y2, tablero=None):
        if tablero is None:
            tablero = self.tablero
        dx = x2 - x1
        dy = y2 - y1
        destino = tablero[x2][y2]

        if dx == 0 and dy == 0:
            return False

        if pieza in self.blancas and destino in self.blancas:
            return False
        if pieza in self.negras and destino in self.negras:
            return False

        if pieza == "âšª":
            if x1 == 6 and dx == -2 and dy == 0 and tablero[x2][y2] in ["â¬œ", "â¬›"] and self.sinPiezas(x1, y1, x2, y2, tablero):
                return True
            if dx == -1 and dy == 0 and tablero[x2][y2] in ["â¬œ", "â¬›"]:
                return True
            if dx == -1 and abs(dy) == 1 and tablero[x2][y2] in self.negras:
                return True
            return False

        if pieza == "âš«":
            if x1 == 1 and dx == 2 and dy == 0 and tablero[x2][y2] in ["â¬œ", "â¬›"] and self.sinPiezas(x1, y1, x2, y2, tablero):
                return True
            if dx == 1 and dy == 0 and tablero[x2][y2] in ["â¬œ", "â¬›"]:
                return True
            if dx == 1 and abs(dy) == 1 and tablero[x2][y2] in self.blancas:
                return True
            return False

        if pieza in ["ğŸ°", "ğŸ¤"]:
            if dx == 0 or dy == 0:
                return self.sinPiezas(x1, y1, x2, y2, tablero)
            return False

        if pieza in ["ğŸ ", "ğŸ´"]:
            return (abs(dx), abs(dy)) in [(2, 1), (1, 2)]

        if pieza in ["â›ª", "ğŸ©"]:
            if abs(dx) == abs(dy):
                return self.sinPiezas(x1, y1, x2, y2, tablero)
            return False

        if pieza in ["ğŸ‘¸", "ğŸ‘©"]:
            if dx == 0 or dy == 0 or abs(dx) == abs(dy):
                return self.sinPiezas(x1, y1, x2, y2, tablero)
            return False

        if pieza in ["ğŸ¤´", "ğŸ‘‘"]:
            return abs(dx) <= 1 and abs(dy) <= 1

        return False

   

    def tirar(self, origen, destino, color):
        try:
            x1, y1 = self.ajedrez_a_matriz(origen)
            x2, y2 = self.ajedrez_a_matriz(destino)
        except ValueError as e:
            print(f"Error de coordenada: {e}")
            return False

        pieza = self.tablero[x1][y1]

        if pieza in ["â¬œ", "â¬›"]:
            return False

        if color == "blancas" and pieza not in self.blancas:
            return False
        if color == "negras" and pieza not in self.negras:
            return False

        if not self.es_movimiento_valido(pieza, x1, y1, x2, y2):
            return False

        if self.tablero[x2][y2] in ["ğŸ¤´", "ğŸ‘‘"]:
            print(f"ğŸ Â¡Â¡JAQUE MATE!! Ganan las {color.upper()} ğŸ")
            self.game = False

        
        if pieza == "âšª" and x2 == 0:
            pieza = "ğŸ‘¸"
        if pieza == "âš«" and x2 == 7:
            pieza = "ğŸ‘©"

        self.tablero[x2][y2] = pieza
        self.tablero[x1][y1] = "â¬œ" if (x1 + y1) % 2 == 0 else "â¬›"
        return True

  

    def agente_blanco(self, profundidad=3):
        
        mejor_valor = -float("inf")
        mejor_mov = None

        movimientos = self.obtener_movimientos_validos("blancas")

        if not movimientos:
            print("No hay movimientos posibles para las blancas (IA).")
            self.game = False
            return False

        for origen, destino in movimientos:
            copia = copy.deepcopy(self)
            copia.tirar(origen, destino, "blancas")
            valor = copia.minimax(profundidad - 1, False, -float("inf"), float("inf"))

            if valor > mejor_valor:
                mejor_valor = valor
                mejor_mov = (origen, destino)

        if mejor_mov:
            print(f" IA mueve {mejor_mov[0]} â†’ {mejor_mov[1]} (valor = {mejor_valor})")
            return self.tirar(mejor_mov[0], mejor_mov[1], "blancas")
        else:
            print("No se encontrÃ³ movimiento para IA.")
            return False

    def minimax(self, profundidad, es_max, alpha, beta):
        
        if profundidad == 0 or not self.game:
            return self.evaluar_tablero()

        color = "blancas" if es_max else "negras"
        movimientos = self.obtener_movimientos_validos(color)

        if not movimientos:
            return self.evaluar_tablero()

        if es_max:
            max_eval = -float("inf")
            for origen, destino in movimientos:
                copia = copy.deepcopy(self)
                copia.tirar(origen, destino, "blancas")
                eval = copia.minimax(profundidad - 1, False, alpha, beta)
                max_eval = max(max_eval, eval)
                alpha = max(alpha, eval)
                if beta <= alpha:
                    break
            return max_eval
        else:
            min_eval = float("inf")
            for origen, destino in movimientos:
                copia = copy.deepcopy(self)
                copia.tirar(origen, destino, "negras")
                eval = copia.minimax(profundidad - 1, True, alpha, beta)
                min_eval = min(min_eval, eval)
                beta = min(beta, eval)
                if beta <= alpha:
                    break
            return min_eval

    def obtener_movimientos_validos(self, color):
        
        movimientos = []
        piezas_color = self.blancas if color == "blancas" else self.negras

        for x in range(8):
            for y in range(8):
                pieza = self.tablero[x][y]
                if pieza in piezas_color:
                    for i in range(8):
                        for j in range(8):
                            if self.es_movimiento_valido(pieza, x, y, i, j):
                                origen = f"{self.columnas[y]}{8-x}"
                                destino = f"{self.columnas[j]}{8-i}"
                                movimientos.append((origen, destino))
        return movimientos

    def evaluar_tablero(self):
        
        valores = {
            "âšª": 10, "ğŸ°": 50, "ğŸ ": 30, "â›ª": 30, "ğŸ‘¸": 90, "ğŸ¤´": 900,
            "âš«": -10, "ğŸ¤": -50, "ğŸ´": -30, "ğŸ©": -30, "ğŸ‘©": -90, "ğŸ‘‘": -900
        }
        valor_total = 0
        for fila in self.tablero:
            for pieza in fila:
                valor_total += valores.get(pieza, 0)
        return valor_total




pygame.init()
WIDTH, HEIGHT = 800, 800
SQUARE_SIZE = WIDTH // 8

WHITE = (255, 255, 255)
BROWN = (139, 69, 19)
YELLOW = (255, 255, 0)

screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("â™Ÿï¸ Ajedrez con IA Minimax")

PIECE_IMAGE_MAP = {
    "ğŸ¤": "images/black_rook.png",
    "ğŸ´": "images/black_knight.png",
    "ğŸ©": "images/black_bishop.png",
    "ğŸ‘©": "images/black_queen.png",
    "ğŸ‘‘": "images/black_king.png",
    "âš«": "images/black_pawn.png",
    "ğŸ°": "images/white_rook.png",
    "ğŸ ": "images/white_knight.png",
    "â›ª": "images/white_bishop.png",
    "ğŸ‘¸": "images/white_queen.png",
    "ğŸ¤´": "images/white_king.png",
    "âšª": "images/white_pawn.png",
}

def load_images():
    images = {}
    for emoji, path in PIECE_IMAGE_MAP.items():
        try:
            img = pygame.image.load(path)
            images[emoji] = pygame.transform.scale(img, (SQUARE_SIZE, SQUARE_SIZE))
        except:
            print(f"No se pudo cargar {path}")
            sys.exit()
    return images

def draw_board(selected_pos):
    for row in range(8):
        for col in range(8):
            color = WHITE if (row + col) % 2 == 0 else BROWN
            pygame.draw.rect(screen, color, (col*SQUARE_SIZE, row*SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE))
    if selected_pos:
        row, col = selected_pos
        pygame.draw.rect(screen, YELLOW, (col*SQUARE_SIZE, row*SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 5)

def draw_pieces(tablero, images):
    for row in range(8):
        for col in range(8):
            emoji = tablero[row][col]
            if emoji in images:
                screen.blit(images[emoji], (col*SQUARE_SIZE, row*SQUARE_SIZE))

def matriz_a_ajedrez(row, col):
    columna_str = chr(ord('a') + col)
    fila_str = str(8 - row)
    return f"{columna_str}{fila_str}"

def handle_click(pos, juego, current_player_color, selected_pos):
    col = pos[0] // SQUARE_SIZE
    row = pos[1] // SQUARE_SIZE
    if selected_pos is None:
        pieza = juego.tablero[row][col]
        if (current_player_color == "blancas" and pieza in juego.blancas) or \
           (current_player_color == "negras" and pieza in juego.negras):
            return (row, col)
        else:
            return None
    else:
        origen_pos_str = matriz_a_ajedrez(selected_pos[0], selected_pos[1])
        destino_pos_str = matriz_a_ajedrez(row, col)
        exito = juego.tirar(origen_pos_str, destino_pos_str, current_player_color)
        if exito:
            juego.turno_negras = not juego.turno_negras
        return None




def main():
    juego = Ajedrez()
    images = load_images()
    selected_pos = None
    clock = pygame.time.Clock()

    while True:
        current_player_color = "negras" if juego.turno_negras else "blancas"

        if not juego.game:
            pygame.time.delay(3000)
            pygame.quit()
            sys.exit()

        if not juego.turno_negras:
            draw_board(selected_pos)
            draw_pieces(juego.tablero, images)
            pygame.display.flip()
            pygame.time.delay(500)
            juego.agente_blanco()
            juego.turno_negras = True
            selected_pos = None
        else:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                elif event.type == pygame.MOUSEBUTTONDOWN:
                    pos = pygame.mouse.get_pos()
                    selected_pos = handle_click(pos, juego, current_player_color, selected_pos)

        draw_board(selected_pos)
        draw_pieces(juego.tablero, images)
        pygame.display.flip()
        clock.tick(60)

if __name__ == "__main__":
    main()
